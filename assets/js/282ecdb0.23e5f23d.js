"use strict";(self.webpackChunkimmer_website=self.webpackChunkimmer_website||[]).push([[777],{5680:(e,t,a)=>{a.d(t,{xA:()=>s,yg:()=>u});var n=a(6540);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var d=n.createContext({}),g=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=g(e.components);return n.createElement(d.Provider,{value:t},e.children)},m="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},y=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,d=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),m=g(a),y=r,u=m["".concat(d,".").concat(y)]||m[y]||p[y]||l;return a?n.createElement(u,i(i({ref:t},s),{},{components:a})):n.createElement(u,i({ref:t},s))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,i=new Array(l);i[0]=y;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[m]="string"==typeof e?e:r,i[1]=o;for(var g=2;g<l;g++)i[g]=a[g];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}y.displayName="MDXCreateElement"},5960:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>d,default:()=>y,frontMatter:()=>o,metadata:()=>g,toc:()=>m});var n=a(8168),r=a(8587),l=(a(6540),a(5680)),i=["components"],o={id:"array-methods",title:"Array Methods Plugin"},d=void 0,g={unversionedId:"array-methods",id:"array-methods",title:"Array Methods Plugin",description:"Overview",source:"@site/docs/array-methods.md",sourceDirName:".",slug:"/array-methods",permalink:"/immer/array-methods",draft:!1,editUrl:"https://github.com/immerjs/immer/edit/main/website/docs/array-methods.md",tags:[],version:"current",frontMatter:{id:"array-methods",title:"Array Methods Plugin"},sidebar:"Immer",previous:{title:"Map and Set",permalink:"/immer/map-set"},next:{title:"Classes",permalink:"/immer/complex-objects"}},s={},m=[{value:"Overview",id:"overview",level:2},{value:"Installation",id:"installation",level:2},{value:"Mutating Methods",id:"mutating-methods",level:2},{value:"Non-Mutating Methods",id:"non-mutating-methods",level:2},{value:"Subset Operations (Return Drafts)",id:"subset-operations-return-drafts",level:3},{value:"Transform Operations (Return Base Values)",id:"transform-operations-return-base-values",level:3},{value:"Primitive-Returning Methods",id:"primitive-returning-methods",level:3},{value:"Methods NOT Overridden",id:"methods-not-overridden",level:2},{value:"Callback Behavior",id:"callback-behavior",level:2},{value:"Method Return Behavior Summary",id:"method-return-behavior-summary",level:2},{value:"When to Use",id:"when-to-use",level:2},{value:"Performance Benefit",id:"performance-benefit",level:2}],p={toc:m};function y(e){var t=e.components,a=(0,r.A)(e,i);return(0,l.yg)("wrapper",(0,n.A)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,l.yg)("center",null,(0,l.yg)("div",{"data-ea-publisher":"immerjs","data-ea-type":"image",className:"horizontal bordered"})),(0,l.yg)("h2",{id:"overview"},"Overview"),(0,l.yg)("p",null,"The Array Methods Plugin (",(0,l.yg)("inlineCode",{parentName:"p"},"enableArrayMethods()"),") optimizes array operations within Immer producers by avoiding unnecessary Proxy creation during iteration. This provides significant performance improvements for array-heavy operations."),(0,l.yg)("p",null,(0,l.yg)("strong",{parentName:"p"},"Why does this matter?")," Without the plugin, every array element access during iteration (e.g., in ",(0,l.yg)("inlineCode",{parentName:"p"},"filter"),", ",(0,l.yg)("inlineCode",{parentName:"p"},"find"),", ",(0,l.yg)("inlineCode",{parentName:"p"},"slice"),") creates a Proxy object. For a 1000-element array, this means 1000+ proxy trap invocations just to iterate. With the plugin enabled, callbacks receive base (non-proxied) values, and proxies are only created as needed for mutation tracking."),(0,l.yg)("h2",{id:"installation"},"Installation"),(0,l.yg)("p",null,"Enable the plugin once at your application's entry point:"),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-javascript"},'import {enableArrayMethods} from "immer"\n\nenableArrayMethods()\n')),(0,l.yg)("p",null,"This adds approximately ",(0,l.yg)("strong",{parentName:"p"},"2KB")," to your bundle size."),(0,l.yg)("h2",{id:"mutating-methods"},"Mutating Methods"),(0,l.yg)("p",null,"These methods modify the array in-place and operate directly on the draft's internal copy without creating per-element proxies:"),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Method"),(0,l.yg)("th",{parentName:"tr",align:null},"Returns"),(0,l.yg)("th",{parentName:"tr",align:null},"Description"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"push()")),(0,l.yg)("td",{parentName:"tr",align:null},"New length"),(0,l.yg)("td",{parentName:"tr",align:null},"Adds elements to the end")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"pop()")),(0,l.yg)("td",{parentName:"tr",align:null},"Removed element"),(0,l.yg)("td",{parentName:"tr",align:null},"Removes and returns the last element")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"shift()")),(0,l.yg)("td",{parentName:"tr",align:null},"Removed element"),(0,l.yg)("td",{parentName:"tr",align:null},"Removes and returns the first element")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"unshift()")),(0,l.yg)("td",{parentName:"tr",align:null},"New length"),(0,l.yg)("td",{parentName:"tr",align:null},"Adds elements to the beginning")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"splice()")),(0,l.yg)("td",{parentName:"tr",align:null},"Removed elements"),(0,l.yg)("td",{parentName:"tr",align:null},"Adds/removes elements at any position")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"sort()")),(0,l.yg)("td",{parentName:"tr",align:null},"The draft array"),(0,l.yg)("td",{parentName:"tr",align:null},"Sorts elements in place")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"reverse()")),(0,l.yg)("td",{parentName:"tr",align:null},"The draft array"),(0,l.yg)("td",{parentName:"tr",align:null},"Reverses the array in place")))),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-javascript"},'import {produce, enableArrayMethods} from "immer"\n\nenableArrayMethods()\n\nconst base = {items: [3, 1, 4, 1, 5]}\n\nconst result = produce(base, draft => {\n    draft.items.push(9) // Adds 9 to end\n    draft.items.sort() // Sorts: [1, 1, 3, 4, 5, 9]\n    draft.items.reverse() // Reverses: [9, 5, 4, 3, 1, 1]\n})\n')),(0,l.yg)("h2",{id:"non-mutating-methods"},"Non-Mutating Methods"),(0,l.yg)("p",null,"Non-mutating methods are categorized based on what they return:"),(0,l.yg)("h3",{id:"subset-operations-return-drafts"},"Subset Operations (Return Drafts)"),(0,l.yg)("p",null,"These methods select items that exist in the original array and ",(0,l.yg)("strong",{parentName:"p"},"create draft proxies")," for the returned items. The callbacks receive ",(0,l.yg)("strong",{parentName:"p"},"base values")," (the optimization), but the ",(0,l.yg)("strong",{parentName:"p"},"returned array")," contains newly created draft proxies that point back to the original positions. ",(0,l.yg)("strong",{parentName:"p"},"Mutations to returned items WILL affect the draft state.")),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Method"),(0,l.yg)("th",{parentName:"tr",align:null},"Returns"),(0,l.yg)("th",{parentName:"tr",align:null},"Drafts?"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"filter()")),(0,l.yg)("td",{parentName:"tr",align:null},"Array of matching items"),(0,l.yg)("td",{parentName:"tr",align:null},"\u2705 Yes")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"slice()")),(0,l.yg)("td",{parentName:"tr",align:null},"Array of items in range"),(0,l.yg)("td",{parentName:"tr",align:null},"\u2705 Yes")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"find()")),(0,l.yg)("td",{parentName:"tr",align:null},"First matching item or ",(0,l.yg)("inlineCode",{parentName:"td"},"undefined")),(0,l.yg)("td",{parentName:"tr",align:null},"\u2705 Yes")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"findLast()")),(0,l.yg)("td",{parentName:"tr",align:null},"Last matching item or ",(0,l.yg)("inlineCode",{parentName:"td"},"undefined")),(0,l.yg)("td",{parentName:"tr",align:null},"\u2705 Yes")))),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-javascript"},"const base = {\n    items: [\n        {id: 1, value: 10},\n        {id: 2, value: 20},\n        {id: 3, value: 30}\n    ]\n}\n\nconst result = produce(base, draft => {\n    // filter returns drafts - mutations track back to original\n    const filtered = draft.items.filter(item => item.value > 15)\n    filtered[0].value = 999 // This WILL affect draft.items[1]\n\n    // find returns a draft - mutations track back\n    const found = draft.items.find(item => item.id === 3)\n    if (found) {\n        found.value = 888 // This WILL affect draft.items[2]\n    }\n\n    // slice returns drafts\n    const sliced = draft.items.slice(0, 2)\n    sliced[0].value = 777 // This WILL affect draft.items[0]\n})\n\nconsole.log(result.items[0].value) // 777\nconsole.log(result.items[1].value) // 999\nconsole.log(result.items[2].value) // 888\n")),(0,l.yg)("h3",{id:"transform-operations-return-base-values"},"Transform Operations (Return Base Values)"),(0,l.yg)("p",null,"These methods create ",(0,l.yg)("strong",{parentName:"p"},"new arrays")," that may include external items or restructured data. They return ",(0,l.yg)("strong",{parentName:"p"},"base values"),", NOT drafts. ",(0,l.yg)("strong",{parentName:"p"},"Mutations to returned items will NOT track back to the draft state.")),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Method"),(0,l.yg)("th",{parentName:"tr",align:null},"Returns"),(0,l.yg)("th",{parentName:"tr",align:null},"Drafts?"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"concat()")),(0,l.yg)("td",{parentName:"tr",align:null},"New combined array"),(0,l.yg)("td",{parentName:"tr",align:null},"\u274c No")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"flat()")),(0,l.yg)("td",{parentName:"tr",align:null},"New flattened array"),(0,l.yg)("td",{parentName:"tr",align:null},"\u274c No")))),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-javascript"},"const base = {items: [{id: 1, value: 10}]}\n\nconst result = produce(base, draft => {\n    // concat returns base values - mutations DON'T track\n    const concatenated = draft.items.concat([{id: 2, value: 20}])\n    concatenated[0].value = 999 // This will NOT affect draft.items[0]\n\n    // To actually use concat results, assign them:\n    draft.items = draft.items.concat([{id: 2, value: 20}])\n})\n\n// Original unchanged because concat result wasn't assigned\nconsole.log(result.items[0].value) // 10 (unchanged)\n")),(0,l.yg)("p",null,(0,l.yg)("strong",{parentName:"p"},"Why the distinction?")),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("strong",{parentName:"li"},"Subset operations")," (",(0,l.yg)("inlineCode",{parentName:"li"},"filter"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"slice"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"find"),") select items that exist in the original array. Returning drafts allows mutations to propagate back to the source."),(0,l.yg)("li",{parentName:"ul"},(0,l.yg)("strong",{parentName:"li"},"Transform operations")," (",(0,l.yg)("inlineCode",{parentName:"li"},"concat"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"flat"),") create new data structures that may include external items or restructured data, making draft tracking impractical.")),(0,l.yg)("h3",{id:"primitive-returning-methods"},"Primitive-Returning Methods"),(0,l.yg)("p",null,"These methods return primitive values (numbers, booleans, strings). No tracking issues since primitives aren't draftable:"),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Method"),(0,l.yg)("th",{parentName:"tr",align:null},"Returns"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"indexOf()")),(0,l.yg)("td",{parentName:"tr",align:null},"Number (index or -1)")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"lastIndexOf()")),(0,l.yg)("td",{parentName:"tr",align:null},"Number (index or -1)")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"includes()")),(0,l.yg)("td",{parentName:"tr",align:null},"Boolean")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"some()")),(0,l.yg)("td",{parentName:"tr",align:null},"Boolean")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"every()")),(0,l.yg)("td",{parentName:"tr",align:null},"Boolean")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"findIndex()")),(0,l.yg)("td",{parentName:"tr",align:null},"Number (index or -1)")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"findLastIndex()")),(0,l.yg)("td",{parentName:"tr",align:null},"Number (index or -1)")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"join()")),(0,l.yg)("td",{parentName:"tr",align:null},"String")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"toString()")),(0,l.yg)("td",{parentName:"tr",align:null},"String")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"toLocaleString()")),(0,l.yg)("td",{parentName:"tr",align:null},"String")))),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-javascript"},"const base = {\n    items: [\n        {id: 1, active: true},\n        {id: 2, active: false}\n    ]\n}\n\nconst result = produce(base, draft => {\n    const index = draft.items.findIndex(item => item.id === 2)\n    const hasActive = draft.items.some(item => item.active)\n    const allActive = draft.items.every(item => item.active)\n\n    console.log(index) // 1\n    console.log(hasActive) // true\n    console.log(allActive) // false\n})\n")),(0,l.yg)("h2",{id:"methods-not-overridden"},"Methods NOT Overridden"),(0,l.yg)("p",null,"The following methods are ",(0,l.yg)("strong",{parentName:"p"},"not")," intercepted by the plugin and work through standard Proxy behavior. Callbacks receive drafts, and mutations track normally:"),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Method"),(0,l.yg)("th",{parentName:"tr",align:null},"Description"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"map()")),(0,l.yg)("td",{parentName:"tr",align:null},"Transform each element")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"flatMap()")),(0,l.yg)("td",{parentName:"tr",align:null},"Map then flatten")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"forEach()")),(0,l.yg)("td",{parentName:"tr",align:null},"Execute callback for each element")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"reduce()")),(0,l.yg)("td",{parentName:"tr",align:null},"Reduce to single value")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"reduceRight()")),(0,l.yg)("td",{parentName:"tr",align:null},"Reduce from right to left")))),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-javascript"},"const base = {\n    items: [\n        {id: 1, value: 10, nested: {count: 0}},\n        {id: 2, value: 20, nested: {count: 0}}\n    ]\n}\n\nconst result = produce(base, draft => {\n    // forEach receives drafts - mutations work normally\n    draft.items.forEach(item => {\n        item.value *= 2\n    })\n\n    // map is NOT overridden - callbacks receive drafts\n    // The returned array items are also drafts (extracted from draft.items)\n    const mapped = draft.items.map(item => item.nested)\n    // Mutations to the result array propagate back\n    mapped[0].count = 999 // \u2705 This affects draft.items[0].nested.count\n})\n\nconsole.log(result.items[0].nested.count) // 999\n")),(0,l.yg)("h2",{id:"callback-behavior"},"Callback Behavior"),(0,l.yg)("p",null,"For overridden methods, callbacks receive ",(0,l.yg)("strong",{parentName:"p"},"base values")," (not drafts). This is the core optimization - it avoids creating proxies for every element during iteration."),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-javascript"},"const base = {\n    items: [\n        {id: 1, value: 10},\n        {id: 2, value: 20}\n    ]\n}\n\nproduce(base, draft => {\n    draft.items.filter(item => {\n        // `item` is a base value here, NOT a draft\n        // Reading properties works fine\n        return item.value > 15\n\n        // But direct mutation here won't be tracked:\n        // item.value = 999  // \u274c Won't affect draft\n    })\n\n    // Instead, use the returned draft:\n    const filtered = draft.items.filter(item => item.value > 15)\n    filtered[0].value = 999 // \u2705 This works because filtered[0] is a draft\n})\n")),(0,l.yg)("h2",{id:"method-return-behavior-summary"},"Method Return Behavior Summary"),(0,l.yg)("table",null,(0,l.yg)("thead",{parentName:"table"},(0,l.yg)("tr",{parentName:"thead"},(0,l.yg)("th",{parentName:"tr",align:null},"Category"),(0,l.yg)("th",{parentName:"tr",align:null},"Methods"),(0,l.yg)("th",{parentName:"tr",align:null},"Returns"),(0,l.yg)("th",{parentName:"tr",align:null},"Mutations Track?"))),(0,l.yg)("tbody",{parentName:"table"},(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("strong",{parentName:"td"},"Subset")),(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"filter"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"slice"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"find"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"findLast")),(0,l.yg)("td",{parentName:"tr",align:null},"Draft proxies"),(0,l.yg)("td",{parentName:"tr",align:null},"\u2705 Yes")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("strong",{parentName:"td"},"Transform")),(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"concat"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"flat")),(0,l.yg)("td",{parentName:"tr",align:null},"Base values"),(0,l.yg)("td",{parentName:"tr",align:null},"\u274c No")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("strong",{parentName:"td"},"Primitive")),(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"indexOf"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"includes"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"some"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"every"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"findIndex"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"findLastIndex"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"lastIndexOf"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"join"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"toString"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"toLocaleString")),(0,l.yg)("td",{parentName:"tr",align:null},"Primitives"),(0,l.yg)("td",{parentName:"tr",align:null},"N/A")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("strong",{parentName:"td"},"Mutating")),(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"push"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"pop"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"shift"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"unshift"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"splice"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"sort"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"reverse")),(0,l.yg)("td",{parentName:"tr",align:null},"Various"),(0,l.yg)("td",{parentName:"tr",align:null},"\u2705 Yes (modifies draft)")),(0,l.yg)("tr",{parentName:"tbody"},(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("strong",{parentName:"td"},"Not Overridden")),(0,l.yg)("td",{parentName:"tr",align:null},(0,l.yg)("inlineCode",{parentName:"td"},"map"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"flatMap"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"forEach"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"reduce"),", ",(0,l.yg)("inlineCode",{parentName:"td"},"reduceRight")),(0,l.yg)("td",{parentName:"tr",align:null},"Standard behavior"),(0,l.yg)("td",{parentName:"tr",align:null},"\u2705 Yes (callbacks get drafts)")))),(0,l.yg)("h2",{id:"when-to-use"},"When to Use"),(0,l.yg)("p",null,"Enable the Array Methods Plugin when:"),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},"Your application has significant array iteration within producers"),(0,l.yg)("li",{parentName:"ul"},"You frequently use methods like ",(0,l.yg)("inlineCode",{parentName:"li"},"filter"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"find"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"some"),", ",(0,l.yg)("inlineCode",{parentName:"li"},"every")," on large arrays"),(0,l.yg)("li",{parentName:"ul"},"Performance profiling shows array operations as a bottleneck")),(0,l.yg)("p",null,"The plugin is most beneficial for:"),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},"Large arrays (100+ elements)"),(0,l.yg)("li",{parentName:"ul"},"Frequent producer calls with array operations"),(0,l.yg)("li",{parentName:"ul"},"Read-heavy operations (filtering, searching) where most elements aren't modified")),(0,l.yg)("h2",{id:"performance-benefit"},"Performance Benefit"),(0,l.yg)("p",null,(0,l.yg)("strong",{parentName:"p"},"Without the plugin:")),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},"Every array element access during iteration creates a Proxy"),(0,l.yg)("li",{parentName:"ul"},"A ",(0,l.yg)("inlineCode",{parentName:"li"},"filter()")," on 1000 elements = 1000+ proxy creations")),(0,l.yg)("p",null,(0,l.yg)("strong",{parentName:"p"},"With the plugin:")),(0,l.yg)("ul",null,(0,l.yg)("li",{parentName:"ul"},"Callbacks receive base values directly"),(0,l.yg)("li",{parentName:"ul"},"Proxies only created for the specific elements you actually mutate, or that match filtering predicates")),(0,l.yg)("pre",null,(0,l.yg)("code",{parentName:"pre",className:"language-javascript"},"// Without plugin: ~3000+ proxy trap invocations\n// With plugin: ~10-20 proxy trap invocations\nconst result = produce(largeState, draft => {\n    const filtered = draft.items.filter(x => x.value > threshold)\n    // Only items you mutate get proxied\n    filtered.forEach(item => {\n        item.processed = true\n    })\n})\n")))}y.isMDXComponent=!0}}]);