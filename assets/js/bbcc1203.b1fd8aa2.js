"use strict";(self.webpackChunkimmer_website=self.webpackChunkimmer_website||[]).push([[927],{5680:(e,t,a)=>{a.d(t,{xA:()=>p,yg:()=>m});var n=a(6540);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},h="mdxType",g={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),h=l(a),d=r,m=h["".concat(c,".").concat(d)]||h[d]||g[d]||s;return a?n.createElement(m,i(i({ref:t},p),{},{components:a})):n.createElement(m,i({ref:t},p))}));function m(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,i=new Array(s);i[0]=d;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o[h]="string"==typeof e?e:r,i[1]=o;for(var l=2;l<s;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},8480:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>l,toc:()=>h});var n=a(8168),r=a(8587),s=(a(6540),a(5680)),i=["components"],o={id:"patches",title:"Patches"},c=void 0,l={unversionedId:"patches",id:"patches",title:"Patches",description:"<div",source:"@site/docs/patches.mdx",sourceDirName:".",slug:"/patches",permalink:"/immer/patches",draft:!1,editUrl:"https://github.com/immerjs/immer/edit/main/website/docs/patches.mdx",tags:[],version:"current",frontMatter:{id:"patches",title:"Patches"},sidebar:"Immer",previous:{title:"Original",permalink:"/immer/original"},next:{title:"Auto freezing",permalink:"/immer/freezing"}},p={},h=[{value:"<code>produceWithPatches</code>",id:"producewithpatches",level:3}],g={toc:h};function d(e){var t=e.components,a=(0,r.A)(e,i);return(0,s.yg)("wrapper",(0,n.A)({},g,a,{components:t,mdxType:"MDXLayout"}),(0,s.yg)("center",null,(0,s.yg)("div",{"data-ea-publisher":"immerjs","data-ea-type":"image",className:"horizontal bordered"}))," ",(0,s.yg)("details",null,(0,s.yg)("summary",{className:"egghead-summary"},"egghead.io lesson 14: Capture patches using _produceWithPatches_"),(0,s.yg)("br",null),(0,s.yg)("div",null,(0,s.yg)("iframe",{width:"760",height:"427",scrolling:"no",src:"https://egghead.io/lessons/react-capture-patches-to-distribute-changes-in-app-state-with-immer-producewithpatches/embed"})),(0,s.yg)("a",{className:"egghead-link",href:"https://egghead.io/lessons/react-capture-patches-to-distribute-changes-in-app-state-with-immer-producewithpatches"},"Hosted on egghead.io"))," ",(0,s.yg)("details",null,(0,s.yg)("summary",{className:"egghead-summary"},"egghead.io lesson 16: Apply Patches using _applyPatches_"),(0,s.yg)("br",null),(0,s.yg)("div",null,(0,s.yg)("iframe",{width:"760",height:"427",scrolling:"no",src:"https://egghead.io/lessons/react-apply-patches-using-immer-applypatches-to-synchronize-state-across-clients/embed"})),(0,s.yg)("a",{className:"egghead-link",href:"https://egghead.io/lessons/react-apply-patches-using-immer-applypatches-to-synchronize-state-across-clients"},"Hosted on egghead.io")),(0,s.yg)("p",null,(0,s.yg)("em",{parentName:"p"},"\u26a0 Since version 6 support for Patches has to be enabled explicitly by calling ",(0,s.yg)("a",{parentName:"em",href:"/immer/installation#pick-your-immer-version"},(0,s.yg)("inlineCode",{parentName:"a"},"enablePatches()"))," once when starting your application.")),(0,s.yg)("p",null,"During the run of a producer, Immer can record all the patches that would replay the changes made by the reducer. This is a very powerful tool if you want to fork your state temporarily and replay the changes to the original."),(0,s.yg)("p",null,"Patches are useful in few scenarios:"),(0,s.yg)("ul",null,(0,s.yg)("li",{parentName:"ul"},"To exchange incremental updates with other parties, for example over websockets"),(0,s.yg)("li",{parentName:"ul"},"For debugging / traces, to see precisely how state is changed over time"),(0,s.yg)("li",{parentName:"ul"},"As basis for undo/redo or as an approach to replay changes on a slightly different state tree")),(0,s.yg)("p",null,"To help with replaying patches, ",(0,s.yg)("inlineCode",{parentName:"p"},"applyPatches")," comes in handy. Here is an example how patches could be used to record the incremental updates and (inverse) apply them:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-javascript"},'import {produce, applyPatches} from "immer"\n\n// version 6\nimport {enablePatches} from "immer"\nenablePatches()\n\nlet state = {\n    name: "Micheal",\n    age: 32\n}\n\n// Let\'s assume the user is in a wizard, and we don\'t know whether\n// his changes should end up in the base state ultimately or not...\nlet fork = state\n// all the changes the user made in the wizard\nlet changes = []\n// the inverse of all the changes made in the wizard\nlet inverseChanges = []\n\nfork = produce(\n    fork,\n    draft => {\n        draft.age = 33\n    },\n    // The third argument to produce is a callback to which the patches will be fed\n    (patches, inversePatches) => {\n        changes.push(...patches)\n        inverseChanges.push(...inversePatches)\n    }\n)\n\n// In the meantime, our original state is replaced, as, for example,\n// some changes were received from the server\nstate = produce(state, draft => {\n    draft.name = "Michel"\n})\n\n// When the wizard finishes (successfully) we can replay the changes that were in the fork onto the *new* state!\nstate = applyPatches(state, changes)\n\n// state now contains the changes from both code paths!\nexpect(state).toEqual({\n    name: "Michel", // changed by the server\n    age: 33 // changed by the wizard\n})\n\n// Finally, even after finishing the wizard, the user might change his mind and undo his changes...\nstate = applyPatches(state, inverseChanges)\nexpect(state).toEqual({\n    name: "Michel", // Not reverted\n    age: 32 // Reverted\n})\n')),(0,s.yg)("p",null,"The generated patches are similar (but not the same) to the ",(0,s.yg)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc6902/#section-4.1"},"RFC-6902 JSON patch standard"),", except that the ",(0,s.yg)("inlineCode",{parentName:"p"},"path")," property is an array, rather than a string. This makes processing patches easier. If you want to normalize to the official specification, ",(0,s.yg)("inlineCode",{parentName:"p"},'patch.path = patch.path.join("/")')," should do the trick. Anyway, this is what a bunch of patches and their inverse could look like:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-json"},'[\n    {\n        "op": "replace",\n        "path": ["profile"],\n        "value": {"name": "Veria", "age": 5}\n    },\n    {"op": "remove", "path": ["tags", 3]}\n]\n')),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-json"},'[\n    {"op": "replace", "path": ["profile"], "value": {"name": "Noa", "age": 6}},\n    {"op": "add", "path": ["tags", 3], "value": "kiddo"}\n]\n')),(0,s.yg)("p",null,"\u26a0 Note: The set of patches generated by Immer should be correct, that is, applying them to an equal base object should result in the same end state. However Immer does not guarantee the generated set of patches will be optimal, that is, the minimum set of patches possible. It depends often on the use case what is considered 'optimal', and generating the optimal set of patches is potentially computationally very expensive. So in cases you might want to post process the generated patches, or compress them as explained below."),(0,s.yg)("h3",{id:"producewithpatches"},(0,s.yg)("inlineCode",{parentName:"h3"},"produceWithPatches")),(0,s.yg)("details",null,(0,s.yg)("summary",{className:"egghead-summary"},"egghead.io lesson 19: Using inverse patches to build undo functionality"),(0,s.yg)("br",null),(0,s.yg)("div",null,(0,s.yg)("iframe",{width:"760",height:"427",scrolling:"no",src:"https://egghead.io/lessons/react-use-immer-inversepatches-to-build-undo-functionality/embed"})),(0,s.yg)("a",{className:"egghead-link",href:"https://egghead.io/lessons/react-use-immer-inversepatches-to-build-undo-functionality"},"Hosted on egghead.io"))," ",(0,s.yg)("details",null,(0,s.yg)("summary",{className:"egghead-summary"},"egghead.io lesson 20: Use patches to build redo functionality"),(0,s.yg)("br",null),(0,s.yg)("div",null,(0,s.yg)("iframe",{width:"760",height:"427",scrolling:"no",src:"https://egghead.io/lessons/react-use-immer-patches-to-build-redo-functionality/embed"})),(0,s.yg)("a",{className:"egghead-link",href:"https://egghead.io/lessons/react-use-immer-patches-to-build-redo-functionality"},"Hosted on egghead.io")),(0,s.yg)("p",null,"Instead of setting up a patch listener, an easier way to obtain the patches is to use ",(0,s.yg)("inlineCode",{parentName:"p"},"produceWithPatches"),", which has the same signature as ",(0,s.yg)("inlineCode",{parentName:"p"},"produce"),", except that it doesn't return just the next state, but a tuple consisting of ",(0,s.yg)("inlineCode",{parentName:"p"},"[nextState, patches, inversePatches]"),". Like ",(0,s.yg)("inlineCode",{parentName:"p"},"produce"),", ",(0,s.yg)("inlineCode",{parentName:"p"},"produceWithPatches")," supports currying as well."),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-javascript"},'import {produceWithPatches} from "immer"\n\nconst [nextState, patches, inversePatches] = produceWithPatches(\n    {\n        age: 33\n    },\n    draft => {\n        draft.age++\n    }\n)\n')),(0,s.yg)("p",null,"Which produces:"),(0,s.yg)("pre",null,(0,s.yg)("code",{parentName:"pre",className:"language-javascript"},'[\n    {\n        age: 34\n    },\n    [\n        {\n            op: "replace",\n            path: ["age"],\n            value: 34\n        }\n    ],\n    [\n        {\n            op: "replace",\n            path: ["age"],\n            value: 33\n        }\n    ]\n]\n')),(0,s.yg)("p",null,"For a more in-depth study, see ",(0,s.yg)("a",{parentName:"p",href:"https://medium.com/@mweststrate/distributing-state-changes-using-snapshots-patches-and-actions-part-2-2f50d8363988"},"Distributing patches and rebasing actions using Immer")),(0,s.yg)("p",null,"Tip: Check this trick to ",(0,s.yg)("a",{parentName:"p",href:"https://medium.com/@david.b.edelstein/using-immer-to-compress-immer-patches-f382835b6c69"},"compress patches")," produced over time."))}d.isMDXComponent=!0}}]);