"use strict";(self.webpackChunkimmer_website=self.webpackChunkimmer_website||[]).push([[208],{5680:(e,r,t)=>{t.d(r,{xA:()=>m,yg:()=>g});var a=t(6540);function n(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function o(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?o(Object(t),!0).forEach((function(r){n(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,a,n=function(e,r){if(null==e)return{};var t,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],r.indexOf(t)>=0||(n[t]=e[t]);return n}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var l=a.createContext({}),p=function(e){var r=a.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):i(i({},r),e)),t},m=function(e){var r=p(e.components);return a.createElement(l.Provider,{value:r},e.children)},c="mdxType",d={inlineCode:"code",wrapper:function(e){var r=e.children;return a.createElement(a.Fragment,{},r)}},u=a.forwardRef((function(e,r){var t=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=p(t),u=n,g=c["".concat(l,".").concat(u)]||c[u]||d[u]||o;return t?a.createElement(g,i(i({ref:r},m),{},{components:t})):a.createElement(g,i({ref:r},m))}));function g(e,r){var t=arguments,n=r&&r.mdxType;if("string"==typeof e||n){var o=t.length,i=new Array(o);i[0]=u;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s[c]="string"==typeof e?e:n,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},3424:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>m,contentTitle:()=>l,default:()=>u,frontMatter:()=>s,metadata:()=>p,toc:()=>c});var a=t(8168),n=t(8587),o=(t(6540),t(5680)),i=["components"],s={id:"performance",title:"Immer performance"},l=void 0,p={unversionedId:"performance",id:"performance",title:"Immer performance",description:"<div",source:"@site/docs/performance.mdx",sourceDirName:".",slug:"/performance",permalink:"/immer/performance",draft:!1,editUrl:"https://github.com/immerjs/immer/edit/main/website/docs/performance.mdx",tags:[],version:"current",frontMatter:{id:"performance",title:"Immer performance"},sidebar:"Immer",previous:{title:"TypeScript / Flow",permalink:"/immer/typescript"},next:{title:"External resources",permalink:"/immer/resources"}},m={},c=[{value:"Performance tips",id:"performance-tips",level:2},{value:"Enable the Array Methods Plugin",id:"enable-the-array-methods-plugin",level:3},{value:"Use loose iteration for better performance",id:"use-loose-iteration-for-better-performance",level:3},{value:"Pre-freeze data",id:"pre-freeze-data",level:3},{value:"You can always opt-out",id:"you-can-always-opt-out",level:3},{value:"For expensive search operations, read from the original state, not the draft",id:"for-expensive-search-operations-read-from-the-original-state-not-the-draft",level:3},{value:"Pull produce as far up as possible",id:"pull-produce-as-far-up-as-possible",level:3}],d={toc:c};function u(e){var r=e.components,s=(0,n.A)(e,i);return(0,o.yg)("wrapper",(0,a.A)({},d,s,{components:r,mdxType:"MDXLayout"}),(0,o.yg)("center",null,(0,o.yg)("div",{"data-ea-publisher":"immerjs","data-ea-type":"image",className:"horizontal bordered"}))," ",(0,o.yg)("details",null,(0,o.yg)("summary",{className:"egghead-summary"},"egghead.io lesson 5: Leveraging Immer's structural sharing in React"),(0,o.yg)("br",null),(0,o.yg)("div",null,(0,o.yg)("iframe",{width:"760",height:"427",scrolling:"no",src:"https://egghead.io/lessons/react-profile-react-rendering-and-optimize-with-memo-to-leverage-structural-sharing/embed"})),(0,o.yg)("a",{className:"egghead-link",href:"https://egghead.io/lessons/react-profile-react-rendering-and-optimize-with-memo-to-leverage-structural-sharing"},"Hosted on egghead.io"))," ",(0,o.yg)("details",null,(0,o.yg)("summary",{className:"egghead-summary"},"egghead.io lesson 7: Immer will try to re-cycle data if there was no semantic change"),(0,o.yg)("br",null),(0,o.yg)("div",null,(0,o.yg)("iframe",{width:"760",height:"427",scrolling:"no",src:"https://egghead.io/lessons/javascript-produces-immutable-data-and-avoid-unnecessary-creation-of-new-data-trees-with-immer/embed"})),(0,o.yg)("a",{className:"egghead-link",href:"https://egghead.io/lessons/javascript-produces-immutable-data-and-avoid-unnecessary-creation-of-new-data-trees-with-immer"},"Hosted on egghead.io")),(0,o.yg)("p",null,"Here is a ",(0,o.yg)("a",{parentName:"p",href:"https://github.com/immerjs/immer/blob/main/__performance_tests__/todo.js"},"simple benchmark")," on the performance of Immer. This test takes 50,000 todo items and updates 5,000 of them. ",(0,o.yg)("em",{parentName:"p"},"Freeze")," indicates that the state tree has been frozen after producing it. This is a ",(0,o.yg)("em",{parentName:"p"},"development")," best practice, as it prevents developers from accidentally modifying the state tree."),(0,o.yg)("p",null,"Something that isn't reflected in the numbers above, but in reality, Immer is sometimes significantly ",(0,o.yg)("em",{parentName:"p"},"faster"),' than a hand written reducer. The reason for that is that Immer will detect "no-op" state changes, and return the original state if nothing actually changed, which can avoid a lot of re-renderings for example. Cases are known where simply applying immer solved critical performance issues.'),(0,o.yg)("p",null,"These tests were executed on Node 10.16.3. Use ",(0,o.yg)("inlineCode",{parentName:"p"},"yarn test:perf")," to reproduce them locally."),(0,o.yg)("p",null,(0,o.yg)("img",{alt:"performance.png",src:t(3469).A,width:"773",height:"530"})),(0,o.yg)("p",null,"Most important observation:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Immer with proxies is roughly speaking twice to three times slower as a handwritten reducer (the above test case is worst case, see ",(0,o.yg)("inlineCode",{parentName:"li"},"yarn test:perf")," for more tests). This is in practice negligible."),(0,o.yg)("li",{parentName:"ul"},"Immer is roughly as fast as ImmutableJS. However, the ",(0,o.yg)("em",{parentName:"li"},"immutableJS + toJS")," makes clear the cost that often needs to be paid later; converting the immutableJS objects back to plain objects, to be able to pass them to components, over the network etc... (And there is also the upfront cost of converting data received from e.g. the server to immutable JS)"),(0,o.yg)("li",{parentName:"ul"},"Generating patches doesn't significantly slow down immer"),(0,o.yg)("li",{parentName:"ul"},"The ES5 fallback implementation is roughly twice as slow as the proxy implementation, in some cases worse.")),(0,o.yg)("h2",{id:"performance-tips"},"Performance tips"),(0,o.yg)("h3",{id:"enable-the-array-methods-plugin"},"Enable the Array Methods Plugin"),(0,o.yg)("p",null,"For applications with significant array iteration within producers, enable the ",(0,o.yg)("a",{parentName:"p",href:"/immer/array-methods"},"Array Methods Plugin"),":"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-javascript"},'import {enableArrayMethods} from "immer"\nenableArrayMethods()\n')),(0,o.yg)("p",null,"This plugin optimizes array operations like ",(0,o.yg)("inlineCode",{parentName:"p"},"filter"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"find"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"some"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"every"),", and ",(0,o.yg)("inlineCode",{parentName:"p"},"slice")," by avoiding proxy creation for every element during iteration. Without the plugin, iterating a 1000-element array creates 1000+ proxies. With the plugin, callbacks receive base values, and proxies are only created for elements you actually mutate."),(0,o.yg)("h3",{id:"use-loose-iteration-for-better-performance"},"Use loose iteration for better performance"),(0,o.yg)("p",null,"By default, Immer uses loose iteration which only processes enumerable string properties. This is faster than strict iteration which includes symbols and non-enumerable properties. For most use cases, the default is optimal:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-javascript"},'import {setUseStrictIteration} from "immer"\n\n// Default: false (loose iteration for better performance)\nsetUseStrictIteration(false)\n')),(0,o.yg)("p",null,"Only enable strict iteration if you specifically need to track symbol or non-enumerable properties."),(0,o.yg)("h3",{id:"pre-freeze-data"},"Pre-freeze data"),(0,o.yg)("p",null,"When adding a large data set to the state tree in an Immer producer (for example data received from a JSON endpoint), it is worth to call ",(0,o.yg)("inlineCode",{parentName:"p"},"freeze(json)")," on the root of the data that is being added first. To ",(0,o.yg)("em",{parentName:"p"},"shallowly")," freeze it. This will allow Immer to add the new data to the tree faster, as it will avoid the need to ",(0,o.yg)("em",{parentName:"p"},"recursively")," scan and freeze the new data."),(0,o.yg)("h3",{id:"you-can-always-opt-out"},"You can always opt-out"),(0,o.yg)("p",null,"Realize that immer is opt-in everywhere, so it is perfectly fine to manually write super performance critical reducers, and use immer for all the normal ones. Even from within a producer you opt-out from Immer for certain parts of your logic by using utilies ",(0,o.yg)("inlineCode",{parentName:"p"},"original")," or ",(0,o.yg)("inlineCode",{parentName:"p"},"current")," and perform some of your operations on plain JavaScript objects."),(0,o.yg)("h3",{id:"for-expensive-search-operations-read-from-the-original-state-not-the-draft"},"For expensive search operations, read from the original state, not the draft"),(0,o.yg)("p",null,"Immer will convert anything you read in a draft recursively into a draft as well. If you have expensive side effect free operations on a draft that involves a lot of reading, for example finding an index using ",(0,o.yg)("inlineCode",{parentName:"p"},"find(Index)")," in a very large array, you can speed this up by first doing the search, and only call the ",(0,o.yg)("inlineCode",{parentName:"p"},"produce")," function once you know the index. Thereby preventing Immer to turn everything that was searched for in a draft. Or, alternatively, perform the search on the original value of a draft, by using ",(0,o.yg)("inlineCode",{parentName:"p"},"original(someDraft)"),", which boils to the same thing."),(0,o.yg)("h3",{id:"pull-produce-as-far-up-as-possible"},"Pull produce as far up as possible"),(0,o.yg)("p",null,"Always try to pull produce 'up', for example ",(0,o.yg)("inlineCode",{parentName:"p"},"for (let x of y) produce(base, d => d.push(x))")," is exponentially slower than ",(0,o.yg)("inlineCode",{parentName:"p"},"produce(base, d => { for (let x of y) d.push(x)})")))}u.isMDXComponent=!0},3469:(e,r,t)=>{t.d(r,{A:()=>a});const a=t.p+"assets/images/performance-c7f59d06ec36f4a05b6403daada96542.png"}}]);