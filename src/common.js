export const PROXY_STATE =
    typeof Symbol !== "undefined"
        ? Symbol("immer-proxy-state")
        : "__$immer_state"

export const RETURNED_AND_MODIFIED_ERROR =
    "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft."

function verifyMinified() {}

const inProduction =
    (typeof process !== "undefined" && process.env.NODE_ENV === "production") ||
    verifyMinified.name !== "verifyMinified"

let autoFreeze = !inProduction
let useProxies = typeof Proxy !== "undefined"

/**
 * Automatically freezes any state trees generated by immer.
 * This protects against accidental modifications of the state tree outside of an immer function.
 * This comes with a performance impact, so it is recommended to disable this option in production.
 * It is by default enabled.
 *
 * @returns {void}
 */
export function setAutoFreeze(enableAutoFreeze) {
    autoFreeze = enableAutoFreeze
}

export function setUseProxies(value) {
    useProxies = value
}

export function getUseProxies() {
    return useProxies
}

export function isProxy(value) {
    return !!value && !!value[PROXY_STATE]
}

export function isProxyable(value) {
    if (!value) return false
    if (typeof value !== "object") return false
    if (Array.isArray(value)) return true
    if (isMapOrSet(value)) return true
    const proto = Object.getPrototypeOf(value)
    return proto === null || proto === Object.prototype
}

export function freeze(value) {
    if (autoFreeze) {
        Object.freeze(value)
    }
    return value
}

const assign =
    Object.assign ||
    function assign(target, value) {
        for (let key in value) {
            if (has(value, key)) {
                target[key] = value[key]
            }
        }
        return target
    }

export function shallowCopy(value) {
    if (Array.isArray(value)) return value.slice()
    if (isMap(value)) return new Map(value)
    if (isSet(value)) return new Set(value)
    if (value.__proto__ === undefined)
        return Object.assign(Object.create(null), value)
    return Object.assign({}, value)
}

function freezeMapOrSet(value) {
    const insertMethod = isMap(value) ? "set" : "add"
    if (autoFreeze) {
        ;[insertMethod, "delete", "clear"].forEach(function(method) {
            Object.defineProperty(value, method, {
                value: function() {
                    throw "In a frozen state, cannot be mutated"
                },
                enumerable: false,
                writable: false
            })
        })
        Object.freeze(value)
    }
    return value
}

export function each(value, cb) {
    // no do need to iterate through Map/Set when internal values are not proxied
    if (isMapOrSet(value)) return
    if (Array.isArray(value)) {
        for (let i = 0; i < value.length; i++) cb(i, value[i])
    } else {
        for (let key in value) cb(key, value[key])
    }
}

export function has(thing, prop) {
    return Object.prototype.hasOwnProperty.call(thing, prop)
}

// given a base object, returns it if unmodified, or return the changed cloned if modified
export function finalize(base) {
    if (isProxy(base)) {
        const state = base[PROXY_STATE]
        if (state.modified === true) {
            if (state.finalized === true) return state.copy
            state.finalized = true
            return finalizeObject(
                useProxies || isMapOrSet(state.base)
                    ? state.copy
                    : (state.copy = shallowCopy(base)),
                state
            )
        } else {
            return state.base
        }
    }
    finalizeNonProxiedObject(base)
    return base
}

function finalizeObject(copy, state) {
    if (isMapOrSet(copy)) return freezeMapOrSet(copy)
    const base = state.base
    each(copy, (prop, value) => {
        if (value !== base[prop]) copy[prop] = finalize(value)
    })
    return freeze(copy)
}

function finalizeNonProxiedObject(parent) {
    // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original
    // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well
    if (!isProxyable(parent)) return
    if (Object.isFrozen(parent)) return
    if (isMapOrSet(parent)) return freezeMapOrSet(parent)
    each(parent, (i, child) => {
        if (isProxy(child)) {
            parent[i] = finalize(child)
        } else finalizeNonProxiedObject(child)
    })
    // always freeze completely new data
    freeze(parent)
}

export function verifyReturnValue(returnedValue, proxy, isProxyModified) {
    if (returnedValue !== undefined && returnedValue !== proxy) {
        // something was returned, and it wasn't the proxy itself
        if (isProxyModified)
            throw new Error(
                "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft."
            )
    }
}

export function is(x, y) {
    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js
    if (x === y) {
        return x !== 0 || 1 / x === 1 / y
    } else {
        return x !== x && y !== y
    }
}

export function createHiddenProperty(target, prop, value) {
    Object.defineProperty(target, prop, {
        value: value,
        enumerable: false,
        writable: true
    })
}

export function es5MarkChanged(state) {
    if (!state.modified) {
        state.modified = true
        if (state.parent) es5MarkChanged(state.parent)
    }
}

export function markChanged(state, es5) {
    if (!state.modified) {
        state.copy = shallowCopy(state.base)
        if (es5) {
            state.hasCopy = true
            es5MarkChanged(state)
        } else {
            state.modified = true
            // copy the proxies over the base-copy
            Object.assign(state.copy, state.proxies) // yup that works for arrays as well
            if (state.parent) markChanged(state.parent)
        }
    }
}

export function isMap(value) {
    return value instanceof Map
}

export function isSet(value) {
    return value instanceof Set
}

export function isMapOrSet(value) {
    return isMap(value) || isSet(value)
}

const nonMutatingMethods = [
    "forEach",
    "get",
    "has",
    "keys",
    "set",
    "values",
    "entries"
]

const mutatingMethods = ["set", "delete", "clear", "add"]

function source(state) {
    return state.modified ? state.copy : state.base
}

function willMutate(base, method, arg1, arg2) {
    if (method === "add" && base.has(arg1)) {
        return false
    } else if (method === "set" && base.get(arg1) === arg2) {
        return false
    } else if (method === "delete" && !base.has(arg1)) {
        return false
    } else if (method === "clear" && base.size === 0) {
        return false
    }
    return true
}

export function proxyMapOrSet(parentState, base, es5) {
    var proxy = {}
    var proxyState = createState(parentState, base)
    proxy.size = source(proxyState).size
    // better way to add iterator?
    proxy[Symbol.iterator] = function() {
        var nextIndex = 0
        var array = [...source(proxyState)]
        return {
            next: function() {
                return nextIndex < array.length
                    ? {value: array[nextIndex++], done: false}
                    : {done: true}
            }
        }
    }
    nonMutatingMethods.forEach(function(method) {
        if (proxyState.base[method]) {
            proxy[method] = function(x) {
                return source(proxyState)[method](x)
            }
        }
    })
    mutatingMethods.forEach(function(method) {
        proxy[method] = function(a, b) {
            if (
                !proxyState.modified &&
                !willMutate(proxyState.base, method, a, b)
            )
                return
            markChanged(proxyState, es5)
            return proxyState.copy[method](a, b)
        }
    })
    createHiddenProperty(proxy, PROXY_STATE, proxyState)
    return es5 ? {proxy, state: proxyState} : {proxy}
}

export function createState(parent, base) {
    return {
        modified: false,
        finalized: false,
        parent,
        base,
        copy: undefined,
        proxies: {}
    }
}
